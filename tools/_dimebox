#compdef dimebox

# TODO: I don't understand this syntax, does it prevent reloading?
(( $+functions[_dimebox-epochs] )) ||
_dimebox-epochs() {
  local curcontext="$curcontext" state line ret=1
  # TODO: can use summary/name as desc.
  # How many epochs should this show?
}
local jobsDir canInit=1

if [ -d ./experiments/jobs ]; then
  jobsDir='./experiments/jobs/'
  canInit=0
elif [ $(basename `pwd`) = 'experiments' -a -d ./jobs ]; then
  jobsDir='./jobs/'
else
  _arguments '1: :(init)'
  return 0
fi

# TODO: what does this do exactly?
local curcontext="$curcontext" state line ret=1

# TODO -C is what?
_arguments -C \
  '1: :->command'\
  '*:: :->option-or-argument' && ret=0

case $state in
  (command)
    local head=$(find $jobsDir -maxdepth 1 -type d -name '2*' -print -quit 2>/dev/null)

    if [[ -n $head ]]; then
      declare -a commands
      commands=(
        generate:' Generate job files'
        summary:' Summary of experiment'
        submit:' Submit all jobs for an epoch'
        kill:' Kill all jobs for an epoch'
        parse:' Parse results from a given epoch'
        watch:' Monitor the status of results for a given epoch.'
        rm:' Remove the jobs and results for a given epoch.'
        resolve:' Resolve a symbolic epoch to concrete epoch.'
        completion:' Output .bashrc completion script.'
      )
      [ $canInit -ne 0 ] && commands+=('init: Initialize directory structure for experiments')
      _describe -t commands command commands && ret=0
      return 0
    else
      # technically, you could call completion as well, but usually you want to generate
      _arguments '1: :(generate)'
      return 0
    fi
    ;;
  (option-or-argument)
    # TODO: not sure of most idiomatic way to proceed
    case $words[1] in
      (init|completion)
        return 0
      ;;
    esac
esac
