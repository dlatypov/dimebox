#compdef dimebox

local dimebox_dir="$(dirname $(dirname $(readlink -e $(which dimebox))))"

local jobsDir headEpoch canInit=1 maxComplEpochs=5
local epochArg=

if [ -d ./experiments/jobs ]; then
  jobsDir='./experiments/jobs/'
  canInit=0
elif [ $(basename `pwd`) = 'experiments' -a -d ./jobs ]; then
  jobsDir='./jobs/'
else
  _arguments '1: :(init)'
  return 0
fi

# TODO: if epochs share a desc, they get clumped together, which can really screw output
# TODO: need to get _arguments to allow multi-args. Seems that is what is stopping it
# from completing after the first arg. Maybe this needs to be done via state.

headEpoch=$(find $jobsDir -maxdepth 1 -type d -name '2*' -print -quit 2>/dev/null)

(( $+functions[_dimebox-epochs] )) ||
_dimebox-epochs() {
  local files names=() name
  files=( $(find ${jobsDir} -maxdepth 1 -type d -name '2*' -print | head -n ${maxComplEpochs} ) )
  names+="HEAD:$(tail -n+2 "${headEpoch}/run.yml" | head -n 1 | sed 's/^desc: //')"
  # Note: this relies on find sorting files from newest to oldest
  for (( i=2; i<=${#files}; i++ )); do
    case $i in
      2)
        name="HEAD~:"
        ;;
      *)
        name="HEAD~$((i-1))"
        ;;
    esac
    names+="${name}:$(tail -n+2 "${files[i]}/run.yml" | head -n 1 | sed  's/^desc: //')"
  done
  _describe 'values' names
}
(( $+functions[_dimebox-opts-generate] )) ||
_dimebox-opts-generate() {
  _arguments \
    '(-m --machine)'{-m,--machine}'[The machine where the experiments will be run]' \
    '--vc[Grab version control information and store with jobs]' \
    '--no-vc[Do not grab version control information]' \
}
(( $+functions[_dimebox-opts-parse] )) ||
_dimebox-opts-parse() {
  _arguments \
    '(-p --parser)'{-p,--parser}'[Parser used to extract information from each line]' \
    '--agg[For results that have the same keys, summarize into mean, stddev, etc]' \
    '--no-agg[Ignore multiple occurences of same key]'\
    '(-t --tag)'{-t,--tag}'[The tag for the results to show]'\
    '(-s --sortBy)'{-s,--sortBy}'[List of columns to sort output by, e.g cmd, p, etc]'\
    '(-f --filter)'{-f,--filter}'[Predicate expression to filter rows by]'\
    '--select:Only print the specified columns'
}
(( $+functions[_dimebox-opts-submit] )) ||
_dimebox-opts-submit() {
  _arguments \
    '(-m --machine)'{-m,--machine}'[The machine where the experiments will be run]' \
  '--dry-run[Only simulate submission of jobs]'\
  '--force[Submit jobs for epoch even if already launched before]'\
  '--stagger[Set up a chain of dependent jobs so that jobs will only be scheduled k at a time]'\
  '--batch[Size of batch for staggered job submission]'
}
(( $+functions[_dimebox-opts-summary] )) ||
_dimebox-opts-summary() {
  _arguments \
  '--sample[Print a sample job file]'\
  '--no-sample[Do not print a sample job file]'\
  '--vc[Print version control information]'\
  '--no-vc[Do not grab version control information]' \
  '--expfile[Print experiment config YAML file]' \
  '--no-expfile[Do not print experiment config YAML file]'
}
(( $+functions[_dimebox-opts-watch] )) ||
_dimebox-opts-watch() {
  _arguments \
  '--interval[Interval in ms to watch for changes]'
}
(( $+functions[_dimebox-opts-rm] )) ||
_dimebox-opts-rm() {
}
(( $+functions[_dimebox-opts-resolve] )) ||
_dimebox-opts-resolve() {
  _arguments -s \
}
(( $+functions[_dimebox-opts-kill] )) ||
_dimebox-opts-kill() {
  _arguments \
    '(-m --machine)'{-m,--machine}'[The machine where the experiments are run]'
}
(( $+functions[_dimebox-machines] )) ||
_dimebox-machines() {
  local opts=( $(find "${dimebox_dir}/lib/machines" "${HOME}/.dimebox/machines" -readable -name '*.js' -exec basename {} '.js' \; 2>/dev/null) )
  compadd -a opts
}
(( $+functions[_dimebox-parsers] )) ||
_dimebox-parsers() {
  local opts=( $(find "${dimebox_dir}/lib/parsers" "${HOME}/.dimebox/parsers" -readable -name '*.js' -exec basename {} '.js' \; 2>/dev/null) )
  compadd -a opts
}


# TODO: what does this do exactly?
local curcontext="$curcontext" state line ret=1

# TODO -C is what?
_arguments -C \
  '1: :->command'\
  '*:: :->option-or-argument' && ret=0

declare -a commands
commands=(
  generate:'Generate job files'
  summary:'Summary of experiment'
  submit:'Submit all jobs for an epoch'
  kill:'Kill all jobs for an epoch'
  parse:'Parse results from a given epoch'
  watch:'Monitor the status of results for a given epoch.'
  rm:'Remove the jobs and results for a given epoch.'
  resolve:'Resolve a symbolic epoch to concrete epoch.'
  completion:'Output .bashrc completion script.'
)
[ $canInit -ne 0 ] && commands+=('init:Initialize directory structure for experiments')

case $state in
  (command)
    if [[ -n $headEpoch ]]; then
      _describe -t commands command commands && ret=0
      return 0
    else
      # technically, you could call completion as well, but usually you want to generate
      _arguments '1: :(generate)'
      return 0
    fi
    ;;
  (option-or-argument)
    local cmd
    cmd=${${commands[(r)$words[1]:*]%%:*}}
    [[ -z $cmd ]] && return 1

    case $cmd in
      (init|completion)
        return 0
      ;;
    esac

    local current prev
    current=${words[$CURRENT]}
    prev=${words[$CURRENT-1]}
    case $prev in
      (-p|--parser)
        _dimebox-parsers
        return 0
        ;;
      (-m|--machine)
        _dimebox-machines
        return 0
        ;;
      (--interval|--batch|-s|--sortBy|-f|--filter|--select)
        return 0
        ;;
    esac

    for ((i=1; i<$#words; ++i)); do
      [ $i -eq $CURRENT ] && continue

      if [[ ${words[$i]} =~ '(^HEAD|2[0-9]{7})' ]]; then
        epochArg=${words[$i]}
        break
      fi

    done

    case $cmd in
      (generate)
        if [[ ${current} =~ '^-' ]]; then
          eval _dimebox-opts-${cmd}
        else
          for ((i=1; i<$#words; ++i)); do
            if [[ ${words[$i]} =~ '\.yml$' ]]; then
              eval _dimebox-opts-${cmd}
              return 0
            fi
          done
          _files -g '*.yml'
        fi
        ;;
      (summary | submit | parse | watch | rm | resolve | kill)
        if [[ ${current} =~ '^-' ]]; then
          eval _dimebox-opts-${cmd}
        elif [[ -z $epochArg ]]; then
          _dimebox-epochs
        else
        fi
        ;;
      *)
        eval _dimebox-opts-${cmd}
        ;;
    esac
esac
